#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <binreader.h>
#include <error_handler.h>

/* Global variables, a necessary evil. */
unsigned int n_encodings = 0,
             first_enc = 0, 
             sec_enc = 0,
             third_enc = 0;

/* The data divided in channels. */
uint32_t **data_vector = NULL,
         **output_vector = NULL;

bitbuffer *data_buffer = NULL,
          *output_buffer = NULL;

/* The header of the file being encoded. */
binheader *input_file_header;

/* The frequencies vector, generated by the Huffman encoding.  */
uint64_t **frequencies;

/* Specific parameters of each encoding. One value per channel. */
uint32_t *nbits_run = NULL,
         *firsts = NULL,
         *max_bits = NULL,
         *nbits_code = NULL,
         frequency_length;

int curr_channel;

void dec_prepare_input_file(FILE *fp)
{
    input_file_header = malloc(sizeof(binheader));
    binh_get_header(input_file_header, fp, &frequencies, &frequency_length, &firsts, &max_bits, &nbits_run, &nbits_code);
    first_enc = input_file_header->firstEncoding;
    sec_enc = input_file_header->secondEncoding;
    third_enc = input_file_header->thirdEncoding;

    output_buffer = calloc(input_file_header->numChannels, sizeof(bitbuffer));

    output_vector = calloc(input_file_header->numChannels, sizeof(uint32_t *));

    memset(output_vector, NULL, input_file_header->numChannels*sizeof(uint32_t *));

    for(curr_channel=0; curr_channel<input_file_header->numChannels; curr_channel++)
            bget(&(data_buffer[curr_channel]), fp);
}

void dec_prepare_output_file (FILE *fp)
{
    free(input_file_header);
}

void dec_huffman(FILE *in_fp)
{
        printf("Applying Huffman decoding...\n");

        /* First, we need to compute the length of the output vector. */
        uint32_t output_length=0, i;
        for(i=0; i<frequency_length; i++)
                output_length+=frequencies[0][i];

        for(curr_channel=0; curr_channel<input_file_header->numChannels; curr_channel++) {
                if(output_vector[curr_channel])
                        free(output_vector[curr_channel]);

                output_vector[curr_channel] = calloc(output_length, sizeof(uint32_t));

                hf_decode (&(data_buffer[curr_channel]), frequencies[curr_channel], output_vector[curr_channel], frequency_length);
        }
}

void dec_run_length(FILE *in_fp)
{
    printf("Applying run-length decoding...\n");
}

void dec_delta(int previous, FILE *in_fp)
{

        printf("Delta decoding...\n");
}

int main(int argc, char *argv[])
{
    FILE *in_fp, *out_fp;

        
    if((in_fp = fopen(argv[1], "rb"))==NULL){
        IO_OPEN_ERROR;
        return 1;
    }
    
    if((out_fp = fopen(argv[2], "wb+"))==NULL){
        IO_OPEN_ERROR;
        return 1;
    }

    printf("Starting decoding process...\n");

    dec_prepare_input_file(in_fp);

    switch (input_file_header.thirdEncoding){
            case HUFFMAN:
                    dec_huffman();
                    break;
            case RUN_LENGTH:
                    dec_length();
                    break;
            case DELTA: 
                    dec_delta();
    }

    switch(input_file_header.secondEncoding){
            case HUFFMAN:
                    dec_huffman();
                    break;
            case RUN_LENGTH:
                    dec_length();
                    break;
            case DELTA: 
                    dec_delta();
            
    }

    switch(input_file_header.firstEncoding){
            case HUFFMAN:
                    dec_huffman();
                    break;
            case RUN_LENGTH:
                    dec_length();
                    break;
            case DELTA: 
                    dec_delta();
            
    }

    enc_prepare_output_file(out_fp);

    fclose(in_fp);
    fclose(out_fp);
    return 0;
}
