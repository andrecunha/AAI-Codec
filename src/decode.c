#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <binreader.h>
#include <error_handler.h>
#include <huffman.h>
#include <delta.h>
#include <run_length.h>

/* Global variables, a necessary evil. */
unsigned int n_encodings = 0,
             first_enc = 0, 
             sec_enc = 0,
             third_enc = 0;

/* The data divided in channels. */
uint32_t **data_vector = NULL,
         **output_vector = NULL;

bitbuffer *data_buffer = NULL,
          *output_buffer = NULL;

/* The header of the file being encoded. */
binheader *input_file_header;

/* The frequencies vector, generated by the Huffman encoding.  */
uint64_t **frequencies;

/* Specific parameters of each encoding. One value per channel. */
uint32_t *nbits_run = NULL,
         *firsts = NULL,
         *max_bits = NULL,
         *nbits_code = NULL,
         frequency_length = 0;

int curr_channel;

void dec_prepare_input_file(FILE *fp)
{
    printf("Preparing input file...\n");

    input_file_header = malloc(sizeof(binheader));

    printf("Getting header...\n");

    binh_get_header(input_file_header, fp, &frequencies, &frequency_length, &firsts, &max_bits, &nbits_run, &nbits_code);
    printf("CODE: %"PRIu32"\n", nbits_code[0]);
    first_enc = input_file_header->firstEncoding;
    sec_enc = input_file_header->secondEncoding;
    third_enc = input_file_header->thirdEncoding;

    output_buffer = calloc(input_file_header->numChannels, sizeof(bitbuffer));

    output_vector = calloc(input_file_header->numChannels, sizeof(uint32_t *));

    /* TODO: is this right???   
        memset(output_vector, 0, input_file_header->numChannels*sizeof(uint32_t *));
     */

    data_buffer = calloc(input_file_header->numChannels, sizeof(bitbuffer));

    data_vector = calloc(input_file_header->numChannels, sizeof(uint32_t *));

    for(curr_channel=0; curr_channel<input_file_header->numChannels; curr_channel++){
           printf("Reading data buffer");
           if( bget(&(data_buffer[curr_channel]), fp)){
                ERROR("Couldn't read bit buffer from input file");
            }
     }
}

void dec_prepare_output_file (FILE *fp)
{
        for(curr_channel=0; curr_channel<input_file_header->numChannels; curr_channel++) {
                bprint(&output_buffer[curr_channel]);
                if(output_vector[curr_channel])
                        free(output_vector[curr_channel]);
                if(data_vector[curr_channel])
                        free(data_vector[curr_channel]);
                bdestroy(&output_buffer[curr_channel]);
                bdestroy(&data_buffer[curr_channel]);
                if(frequencies && frequencies[curr_channel])
                    free(frequencies[curr_channel]);
        }
        if(nbits_run)
            free(nbits_run);
        if(nbits_code)
            free(nbits_code);
        if(frequencies)
            free(frequencies);
        free(data_buffer);
        free(data_vector);
        free(output_buffer);
        free(output_vector);
        free(input_file_header);
}

void dec_huffman(FILE *in_fp)
{
        printf("Applying Huffman decoding...\n");

        /* First, we need to compute the length of the output vector. */
        uint32_t output_length=0, i;
        for(i=0; i<frequency_length; i++)
                output_length+=frequencies[0][i];

        for(curr_channel=0; curr_channel<input_file_header->numChannels; curr_channel++) {
                if(output_vector[curr_channel])
                        free(output_vector[curr_channel]);

                output_vector[curr_channel] = calloc(output_length, sizeof(uint32_t));

                hf_decode (&(data_buffer[curr_channel]), frequencies[curr_channel], output_vector[curr_channel], frequency_length);
    bdestroy(&data_buffer[curr_channel]);
    binit(&data_buffer[curr_channel], input_file_header->subchunk2size);
     b_from_uint32(&data_buffer[curr_channel], output_vector[curr_channel], 
    output_length, 8,  0);
    bprint(&data_buffer[curr_channel]);
        }
}

void dec_run_length(FILE *in_fp)
{
        printf("Applying run-length decoding...\n");

        for(curr_channel=0; curr_channel<input_file_header->numChannels; curr_channel++) {
            if(sec_enc==RUN_LENGTH){ 
                /* Therefore, the first one was surely delta encoding. */
                
                /*XXX: Precisamos passar os dados do data_vector para o data_buffer. */
                rl_decode(max_bits[curr_channel], nbits_code[curr_channel], nbits_run[curr_channel], &data_buffer[curr_channel], &output_buffer[curr_channel]);
            }else{
                /* Therefore, this is the first one. */
                binit(&output_buffer[curr_channel], input_file_header->subchunk2size);
                rl_decode(input_file_header->bitsPerSample, nbits_code[curr_channel], nbits_run[curr_channel], &data_buffer[curr_channel], &output_buffer[curr_channel]);
            }
        }

}

void dec_delta(FILE *in_fp)
{
        printf("Delta decoding...\n");
        for(curr_channel=0; curr_channel<input_file_header->numChannels; curr_channel++) {
                if(output_vector[curr_channel])
                        free(output_vector[curr_channel]);

                uint32_t output_length = (data_buffer[curr_channel].n_bytes*8 - (8-data_buffer[curr_channel].bits_last))/max_bits[curr_channel];

                output_vector = calloc(output_length, sizeof(uint32_t));

                if(first_enc==DELTA)
                        dt_decode(&data_buffer[curr_channel], max_bits[curr_channel], output_vector[curr_channel], output_length, input_file_header->bitsPerSample, firsts[curr_channel]);
                else
                        /* Here, the previous encoding can only be run-length. */
                        dt_decode(&data_buffer[curr_channel], max_bits[curr_channel], output_vector[curr_channel], output_length, nbits_run[curr_channel] + nbits_code[curr_channel], firsts[curr_channel]);
        }
}

int main(int argc, char *argv[])
{
    FILE *in_fp, *out_fp;
        
    if((in_fp = fopen(argv[1], "rb"))==NULL){
        IO_OPEN_ERROR;
        return 1;
    }
    
    if((out_fp = fopen(argv[2], "wb+"))==NULL){
        IO_OPEN_ERROR;
        return 1;
    }

    printf("Starting decoding process...\n");

    dec_prepare_input_file(in_fp);

    switch (third_enc){
            case HUFFMAN:
                    dec_huffman(in_fp);
                    break;
            case RUN_LENGTH:
                    dec_run_length(in_fp);
                    break;
            case DELTA: 
                    dec_delta(in_fp);
            default:
                    break;
    }

    switch(sec_enc){
            case HUFFMAN:
                    dec_huffman(in_fp);
                    break;
            case RUN_LENGTH:
                    dec_run_length(in_fp);
                    break;
            case DELTA: 
                    dec_delta(in_fp);
            default:
                    break;
    }

    switch(first_enc){
            case HUFFMAN:
                    {
                    dec_huffman(in_fp);
                    }
                    break;
            case RUN_LENGTH:
                   dec_run_length(in_fp);
                    break;
            case DELTA: 
                    dec_delta(in_fp);
            default:
                    break;
    }

    dec_prepare_output_file(out_fp);

    fclose(in_fp);
    fclose(out_fp);
    return 0;
}
